name: $(Date:yyyyMMdd)$(Rev:.r)

# ==================== TRIGGERS CONFIGURATION ====================
trigger:
  branches:
    include:
    - main
    - develop
    - feature/*
  paths:
    include:
    - '**/*.cs'
    - '**/*.csproj'
    - '**/*.sln'
    - '**/*.cshtml'
    - 'Controllers/**'
    - 'Models/**'
    - 'Views/**'
    - 'wwwroot/**'
  batch: true

# ==================== VARIABLES ====================
variables:
  buildConfiguration: 'Release'
  solution: '**/*.sln'
  projects: '**/*.csproj'
  testProjects: '**/*Tests.csproj'
  buildPlatform: 'Any CPU'

# ==================== STAGES ====================
stages:

# STAGE 1: BUILD AND TEST
- stage: Build
  displayName: 'Build and Test Stage'
  jobs:
  - job: BuildAndTest
    displayName: 'Build and Test Application'
    pool:
      vmImage: 'windows-latest'
    
    steps:
    # ========== CODE COMPILATION TASKS ==========
    
    # Task 1: Checkout code
    - checkout: self
      displayName: 'üì• Checkout source code'
      clean: true
      fetchDepth: 1
    
    # Task 2: Install .NET SDK
    - task: UseDotNet@2
      displayName: 'üîß Install .NET 8 SDK'
      inputs:
        packageType: 'sdk'
        version: '8.x'
        includePreviewVersions: false
    
    # Task 3: Display build information
    - task: CmdLine@2
      displayName: '‚ÑπÔ∏è Build information'
      inputs:
        script: |
          echo "Build Source Branch: $(Build.SourceBranch)"
          echo "Build Reason: $(Build.Reason)"
          echo "Build ID: $(Build.BuildId)"
          dotnet --version
          dotnet --info
    
    # Task 4: Restore NuGet packages
    - task: DotNetCoreCLI@2
      displayName: 'üì¶ Restore NuGet packages'
      inputs:
        command: 'restore'
        projects: '$(projects)'
        feedsToUse: 'select'
        verbosityRestore: 'normal'
    
    # Task 5: Build solution
    - task: DotNetCoreCLI@2
      displayName: 'üèóÔ∏è Build solution'
      inputs:
        command: 'build'
        projects: '$(projects)'
        arguments: '--configuration $(buildConfiguration) --no-restore --verbosity normal'
    
    # ========== TESTING TASKS ==========
    
    # Task 6: Create test project if it doesn't exist
    - task: CmdLine@2
      displayName: 'üõ†Ô∏è Setup test project'
      inputs:
        script: |
          # Check if test project exists, if not create one
          if not exist "**/*Tests.csproj" (
            echo "No test project found. Creating basic test project..."
            dotnet new xunit -n GiftOfTheGivers.Tests
            dotnet sln add GiftOfTheGivers.Tests/GiftOfTheGivers.Tests.csproj
            dotnet add GiftOfTheGivers.Tests/GiftOfTheGivers.Tests.csproj reference $(projects)
          )
        workingDirectory: '$(Build.SourcesDirectory)'
      condition: and(succeeded(), not(exists(variables['testProjects'])))
    
    # Task 7: Run unit tests
    - task: DotNetCoreCLI@2
      displayName: 'üß™ Run unit tests'
      inputs:
        command: 'test'
        projects: '$(testProjects)'
        arguments: '--configuration $(buildConfiguration) --no-build --logger "trx" --collect:"XPlat Code Coverage"'
        publishTestResults: true
      condition: succeeded()
    
    # Task 8: Generate test coverage report
    - task: PublishCodeCoverageResults@1
      displayName: 'üìä Publish code coverage'
      inputs:
        codeCoverageTool: 'Cobertura'
        summaryFileLocation: '$(Agent.TempDirectory)/**/coverage.cobertura.xml'
        reportDirectory: '$(Agent.TempDirectory)/**/'
      condition: succeeded()
    
    # ========== ARTIFACT CREATION ==========
    
    # Task 9: Publish application
    - task: DotNetCoreCLI@2
      displayName: 'üì¶ Publish application'
      inputs:
        command: 'publish'
        projects: '$(projects)'
        arguments: '--configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory)/publish --no-build'
        zipAfterPublish: false
      condition: succeeded()
    
    # Task 10: Publish build artifacts
    - task: PublishBuildArtifacts@1
      displayName: 'üì§ Publish build artifacts'
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)'
        ArtifactName: 'webapp'
        publishLocation: 'Container'
      condition: succeeded()

# STAGE 2: DEPLOY TO TEST ENVIRONMENT
- stage: Deploy_Test
  displayName: 'üöÄ Deploy to Test Environment'
  dependsOn: Build
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
  
  jobs:
  - deployment: DeployToTest
    displayName: 'Deploy to Test Environment'
    environment: 'GiftOfTheGivers-Test'
    pool:
      vmImage: 'windows-latest'
    
    strategy:
      runOnce:
        deploy:
          steps:
          # ========== DEPLOYMENT TASKS ==========
          
          # Task 1: Download build artifacts
          - download: current
            displayName: 'üì• Download build artifacts'
            artifact: 'webapp'
          
          # Task 2: Display deployment info
          - task: CmdLine@2
            displayName: '‚ÑπÔ∏è Deployment information'
            inputs:
              script: |
                echo "Deploying to Test Environment"
                echo "Artifact Path: $(Pipeline.Workspace)/webapp"
                dir "$(Pipeline.Workspace)/webapp"
          
          # Task 3: Validate web.config exists
          - task: CmdLine@2
            displayName: '‚úÖ Validate deployment package'
            inputs:
              script: |
                if exist "$(Pipeline.Workspace)/webapp/publish/web.config" (
                  echo "‚úÖ web.config found - Valid ASP.NET Core application"
                ) else (
                  echo "‚ùå web.config not found - Check publish configuration"
                  exit 1
                )
          
          # Task 4: Deploy to Azure App Service (Test Environment)
          - task: AzureWebApp@1
            displayName: 'üåê Deploy to Azure App Service (Test)'
            inputs:
              azureSubscription: 'Your-Azure-Service-Connection' # You'll create this
              appType: 'webApp'
              appName: 'gift-of-the-givers-test'
              package: '$(Pipeline.Workspace)/webapp/publish'
              deploymentMethod: 'auto'
          
          # Task 5: Run health check after deployment
          - task: PowerShell@2
            displayName: 'üè• Health check validation'
            inputs:
              targetType: 'inline'
              script: |
                $testUrl = "https://gift-of-the-givers-test.azurewebsites.net"
                $maxRetries = 10
                $retryCount = 0
                $success = $false
                
                while ($retryCount -lt $maxRetries -and -not $success) {
                  try {
                    Write-Host "Health check attempt $($retryCount + 1)..."
                    $response = Invoke-WebRequest -Uri $testUrl -Method Get -UseBasicParsing -TimeoutSec 30
                    if ($response.StatusCode -eq 200) {
                      $success = $true
                      Write-Host "‚úÖ Health check PASSED - Application is running"
                      break
                    }
                  } catch {
                    Write-Host "‚ùå Health check failed: $($_.Exception.Message)"
                  }
                  
                  $retryCount++
                  if ($retryCount -lt $maxRetries) {
                    Start-Sleep -Seconds 10
                  }
                }
                
                if (-not $success) {
                  Write-Error "‚ùå Health check FAILED after $maxRetries attempts"
                  exit 1
                }
          
          # Task 6: Run smoke tests
          - task: DotNetCoreCLI@2
            displayName: 'üîç Run smoke tests'
            inputs:
              command: 'test'
              projects: '$(testProjects)'
              arguments: '--filter Category=Smoke --logger "trx"'
              publishTestResults: true
            condition: succeeded()

# STAGE 3: VALIDATION AND NOTIFICATION
- stage: Validate
  displayName: '‚úÖ Validation'
  dependsOn: Deploy_Test
  condition: succeeded()
  
  jobs:
  - job: FinalValidation
    displayName: 'Final validation'
    pool:
      vmImage: 'windows-latest'
    
    steps:
    # Task 1: Send success notification
    - task: CmdLine@2
      displayName: 'üì¢ Build and deployment successful'
      inputs:
        script: |
          echo "=========================================="
          echo "‚úÖ PIPELINE EXECUTION COMPLETED SUCCESSFULLY"
          echo "=========================================="
          echo "Application: Gift of the Givers Foundation"
          echo "Build: $(Build.BuildNumber)"
          echo "Deployed to: Test Environment"
          echo "Test URL: https://gift-of-the-givers-test.azurewebsites.net"
          echo "=========================================="